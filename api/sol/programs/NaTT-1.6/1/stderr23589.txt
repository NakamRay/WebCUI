Input TRS:
    1: f(0(),1(),g(X,Y),U) -> f(g(X,Y),g(X,Y),g(X,Y),h(X))
    2: g(0(),1()) -> 0()
    3: g(0(),1()) -> 1()
    4: h(g(V,W)) -> h(V)
    5: map(J,nil()) -> nil()
    6: map(F1,cons(Y1,U1)) -> cons(F1[Y1](),map(F1,U1))
    7: filter(H1,nil()) -> nil()
    8: filter(I1,cons(P1,X2)) -> filter2(I1[P1](),I1,P1,X2)
    9: filter2(true(),Z2,U2,V2) -> cons(U2,filter(Z2,V2))
    10: filter2(false(),I2,P2,X3) -> filter(I2,X3)
Number of strict rules: 10
Direct POLO(bPol) ... failed.
Uncurrying filter2
1: f(0(),1(),g(X,Y),U) -> f(g(X,Y),g(X,Y),g(X,Y),h(X))
2: g(0(),1()) -> 0()
3: g(0(),1()) -> 1()
4: h(g(V,W)) -> h(V)
5: map(J,nil()) -> nil()
6: map(F1,cons(Y1,U1)) -> cons(F1[Y1](),map(F1,U1))
7: filter(H1,nil()) -> nil()
8: filter(I1,cons(P1,X2)) -> filter2^1_I1[P1](I1,P1,X2)
9: filter2^1_true(Z2,U2,V2) -> cons(U2,filter(Z2,V2))
10: filter2^1_false(I2,P2,X3) -> filter(I2,X3)
11: filter2(I1[P1](),_3,_4,_5) ->= filter2^1_I1[P1](_3,_4,_5)
12: filter2(false(),_3,_4,_5) ->= filter2^1_false(_3,_4,_5)
13: filter2(true(),_3,_4,_5) ->= filter2^1_true(_3,_4,_5)
Number of strict rules: 10
Direct POLO(bPol) ... failed.
Dependency Pairs:
   #1: #map(F1,cons(Y1,U1)) -> #map(F1,U1)
   #2: #filter2(true(),_3,_4,_5) ->? #filter2^1_true(_3,_4,_5)
   #3: #filter2^1_true(Z2,U2,V2) -> #filter(Z2,V2)
   #4: #filter2(false(),_3,_4,_5) ->? #filter2^1_false(_3,_4,_5)
   #5: #filter2^1_false(I2,P2,X3) -> #filter(I2,X3)
   #6: #f(0(),1(),g(X,Y),U) -> #f(g(X,Y),g(X,Y),g(X,Y),h(X))
   #7: #f(0(),1(),g(X,Y),U) -> #h(X)
   #8: #h(g(V,W)) -> #h(V)
Number of SCCs: 3, DPs: 3
  SCC { #8 }
POLO(Sum)... succeeded.
      h 	w: 0
      1 	w: 0
      #filter2	w: 0
      #filter	w: 0
      I1[P1]	w: 0
      false	w: 0
      filter2^1_false	w: 0
      #filter2^1_true	w: 0
      true	w: 0
      f 	w: 0
      filter2	w: 0
      filter2^1_I1[P1]	w: 0
      0 	w: 0
      #h 	w: x1
      nil	w: 0
      F1[Y1]	w: 0
      #f 	w: 0
      #g 	w: 0
      map	w: 0
      #map	w: 0
      cons	w: 0
      filter	w: 0
      #filter2^1_false	w: 0
      filter2^1_true	w: 0
      g 	w: x1 + 1
    USABLE RULES: { }
    Removed DPs: #8
Number of SCCs: 2, DPs: 2
  SCC { #1 }
POLO(Sum)... succeeded.
      h 	w: 0
      1 	w: 0
      #filter2	w: 0
      #filter	w: 0
      I1[P1]	w: 0
      false	w: 0
      filter2^1_false	w: 0
      #filter2^1_true	w: 0
      true	w: 0
      f 	w: 0
      filter2	w: 0
      filter2^1_I1[P1]	w: 0
      0 	w: 0
      #h 	w: 0
      nil	w: 0
      F1[Y1]	w: 0
      #f 	w: 0
      #g 	w: 0
      map	w: 0
      #map	w: x2
      cons	w: x2 + 1
      filter	w: 0
      #filter2^1_false	w: 0
      filter2^1_true	w: 0
      g 	w: 1
    USABLE RULES: { }
    Removed DPs: #1
Number of SCCs: 1, DPs: 1
  SCC { #6 }
POLO(Sum)... POLO(max)... QLPOS... POLO(mSum)... QWPOpS(mSum)... Mat2b... failed.
Finding a loop...  found.
  #f(0(),1(),g(0(),1()),U)	-#6->
  #f(g(0(),1()),g(0(),1()),g(0(),1()),h(0()))	--->*
  #f(0(),1(),g(0(),1()),h(0()))
  Looping with: [ U := h(0()); ]
