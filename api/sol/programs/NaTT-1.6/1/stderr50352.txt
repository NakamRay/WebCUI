Input TRS:
    1: letval(T2,x()) -> T2
    2: letval(T3,letval(U4,V4)) -> letval(U4,letval(T3,V4))
Number of strict rules: 2
Direct POLO(bPol) ... removes: 1
      letval	w: 2 * x1 + x2
      x 	w: 1
Number of strict rules: 1
Direct POLO(bPol) ... failed.
Uncurrying ... failed.
Dependency Pairs:
   #1: #letval(T3,letval(U4,V4)) -> #letval(U4,letval(T3,V4))
   #2: #letval(T3,letval(U4,V4)) -> #letval(T3,V4)
Number of SCCs: 1, DPs: 2
  SCC { #1 #2 }
POLO(Sum)... succeeded.
      letval	w: x2 + 1
      #letval	w: x2
      x 	w: 0
    USABLE RULES: { 2 }
    Removed DPs: #2
Number of SCCs: 1, DPs: 1
  SCC { #1 }
POLO(Sum)... POLO(max)... QLPOS... POLO(mSum)... QWPOpS(mSum)... Mat2b... failed.
Finding a loop...  found.
  #letval(T3_{i6},letval(T3_{1},letval(U4_{1},V4_{i6})))	-#1->
  #letval(T3_{1},letval(T3_{i6},letval(U4_{1},V4_{i6})))	--->*
  #letval(T3_{1},letval(U4_{1},letval(T3_{i6},V4_{i6})))
  Looping with: [ V4_{i6} := V4_{i6}; U4_{1} := T3_{i6}; T3_{1} := U4_{1}; T3_{i6} := T3_{1}; ]
