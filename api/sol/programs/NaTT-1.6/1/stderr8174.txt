Input TRS:
    1: f(X,g(X)) -> f(1(),g(X))
    2: g(1()) -> g(0())
    3: map(Z,nil()) -> nil()
    4: map(G,cons(V,W)) -> cons(G[V](),map(G,W))
    5: filter(J,nil()) -> nil()
    6: filter(F1,cons(Y1,U1)) -> filter2(F1[Y1](),F1,Y1,U1)
    7: filter2(true(),H1,W1,P1) -> cons(W1,filter(H1,P1))
    8: filter2(false(),F2,Y2,U2) -> filter(F2,U2)
Number of strict rules: 8
Direct POLO(bPol) ... removes: 4 8 3 5 7 6
      1 	w: 0
      false	w: 1
      true	w: 3
      f 	w: x1 + x2
      filter2	w: 2 * x1 + x2 + 2 * x3 + x4
      0 	w: 0
      nil	w: 1
      F1[Y1]	w: 1
      map	w: x1 + 2 * x2 + 1
      G[V]	w: 1
      cons	w: 2 * x1 + x2 + 3
      filter	w: x1 + x2 + 1
      g 	w: x1 + 1
Number of strict rules: 2
Direct POLO(bPol) ... failed.
Uncurrying ... failed.
Dependency Pairs:
   #1: #g(1()) -> #g(0())
   #2: #f(X,g(X)) -> #f(1(),g(X))
Number of SCCs: 1, DPs: 1
  SCC { #2 }
POLO(Sum)... POLO(max)... QLPOS... POLO(mSum)... QWPOpS(mSum)... Mat2b... failed.
Finding a loop...  found.
  #f(1(),g(1()))	-#2->
  #f(1(),g(1()))	--->*
  #f(1(),g(1()))
  Looping with: [ ]
